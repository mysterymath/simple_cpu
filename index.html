<!doctype html>
<title>A Simple CPU</title>
<meta name="viewport" content="width=device-width">
<style>
    html {
        background-color: #002b36;
    }
    .content {
        color: #839496;
	      font-family: Georgia, serif;
        line-height: 1.5;
        max-width: 60ch;
        margin-left: auto;
        margin-right: auto;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
	      font-family: sans-serif;
        line-height: normal;
    }
    p {
        break-inside: avoid;
        text-align: justify;
    }
    ul,ol {
      break-inside: avoid;
    }
    a:link {
      color: #268bd2;
    }
    a:visited {
      color: #d33682;
    }
    .intro {
        break-inside: avoid;
    }
    code, pre {
      font-size: large;
    }
</style>
<div class="content">
<div class="intro">
<h1>A Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that I can build? Inspired by <i><a
href="http://www.thetoasterproject.org">The Toaster Project</a></i>, I've
been exploring this question.
</div>

<p>"From scratch" and "simplest" are both rather vague. Depending on
interpretation, they could range anywhere from mining copper (hats off to
you, Toaster Guy) to buying a CPU off the shelf. If the task is too easy, it
won't feel satisfying. Too hard and it's not achievable at all. Some ground
rules seem in order.

<p>Making a "simplest" anything almost necessarily involves the most
gratiutous allowable abuse of the rules. Accordingly, the rules will control
a great deal of the project's nature. After carefully examining the
consequences of various rule sets, I've chosen the following:
<ul>
    <li>The CPU should be integrable in a "real system". Together they should
    be capable of doing usual computer things like I/O, addition,
    subtraction, etc.
    <li>Any parts of the CPU purchased from the store must not be specifically intended
    for inclusion in a CPU. This precludes purchasing ALUs and the like.
    <li>No FPGAs, CPLDs or the like in the CPU. Purchased parts must be
    limited in the sorts of functions they be made to directly compute.
    Otherwise this becomes "just another FPGA CPU project."
    <li>The CPU must be responsible for the overall control of the system.
    <li>The CPU should use as few components and wires as possible.
</ul>

<div class="intro">
<h2>Abstract CPU Design</h2>
<p>What exactly does a CPU do? Well, a CPU reads an instruction from the
system, then does whatever it says. Some instructions may involve obtaining
additional information from the system, delivering information to the system,
or both.
</div>

<div class="intro">
<h3>Communciations</h3>
<p>The CPU needs to be able to read/write main memory and to perform I/O. Via
the <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped
I/O</a> approach, certain address regions can be reserved for I/O devices,
with the rest mapping to main memory. I/O devices themselves answer reads and
writes for these regions, and various combinations of reads and writes
correspond to the avialable I/O operations. This allows one mechanism to be
used for all CPU/system communications. Nice and simple for the CPU (although
maybe less so for the I/O devices).
</div>

<p>The address space should be 8-bit byte-addressable, since that's long been
the standard. How big should addresses be? A multiple of 8 bits would allow
them to be stored in RAM without waste. 8-bit addresses would only allow 256
addressable bytes, but 16-bit addresses work just fine, allowing 64KiB of
address space. The addresses are stored big-endian, since that's what the
chips used in the implementation expect.

<div class="intro">
<h3>Instruction Set</h3>
<p> How many different kinds of operations does the CPU need to be able to
perform? If the goal is to be as simple as possible, only one. There are a
dazzling variety of <a
href="https://en.wikipedia.org/wiki/One_instruction_set_computer">one
instruction set computer</a> (OISC) architectures, where the computer has exactly
one way of interacting with the rest of the system. By the magic of
Turing-equivalency, any such processor is able to simulate far more rich
instruction sets, just by repeating that one interaction ad infinitum.
</div>

<p>Of all the OISC available, which is simplest to implement? Our chosen
communication scheme suggests a natural answer: <a
href="https://esolangs.org/wiki/ByteByteJump">byte byte jump</a>. This OISC
consists exclusively of the two basic communication operations: read and
write.

<p>A byte byte jump instruction contains the following 48-bits:
<ul>
    <li>A 16-bit source address
    <li>A 16-bit destination address
    <li>A 16-bit jump address
</ul>

<p>A CPU implementing byte byte jump would do the following repeatedly:
<ul>
    <li>Read the source, destination and jump addresses at the CPU's instruction pointer.
    <li>Read the byte at the source address and write it to the destination address.
    <li>Change the processor's instruction pointer to the jump address.
</ul>

<p>That's it! A CPU that can do the above can compute any computable
function. It's not an ivory tower theoretical "can" either; the reduction is
surprisingly practical (for a hilariously impractical value of practical).

<div class="intro">
<h2>Synthesizing Addition: <a href="https://en.wikipedia.org/wiki/IBM_1620">Can't Add, Doesn't Even Try</a></h2>
<p>To provide an intuition of how computation can be done with just a
glorified move instruction, I'll sketch some of the strategies used to
construct an 8-bit addition operation using only byte byte jump. I'll spare
the details, as the actual construction of such an operation is a bit
intricate, and most of it is not difficult or interesting, but just tedious.

<p>How might one go about constructing addition? Well, imagine we have a
"giant" table that takes up the entire 64KiB address space. Such a table
could be indexed by a pair of 8 bit values; one forming the high byte of the
value, and the other forming the low byte. In such a table, we could just
store the sum of the two indices; an indexed lookup into this table would
allow adding any two 8-bit values.

<p>Unfortunately, this wouldn't leave room in the address space for anything
else. But this is just a matter of size. The complete table of 4-bit by 4-bit
sums occupies only 256 addresses. This leads to a workable approach: do two
separate 4-bit additions, one between the low 4 bits of the input bytes, and
another between the high 4 bits. Incorporate the carry from the low addition
into the high one, and combine the two sums together into a full 8-bit
addition. This can be all accomplished by a series of subsequent lookups in
around 5KiB of tables included with the program.

<p>Given one of these tables, how can byte byte jump perform a lookup? On the
face of it, it seems like the source and destination addresses for any given
instruction are fixed. The trick is an old one: self-modifying code. Either
or both byte of the source address can be overwritten by a prior move
instruction. Specifically, if a table ranges from $xy00 to $xyFF, then
overwriting the low byte of the source address with the offset causes the
next instruction to perform an indexed lookup in that table.

<p>Conditional branches and the like can be achieved using a similar trick,
instead overwriting the jump part of the address instead of the source.

<p>The above technique works byte at a time, which gives obvious access to
two table sizes: 8-bit and 16-bit. However, no 16-bit tables can be used,
since they would consume the entire address space, leaving no room for the
program. A 12-bit table only occupies 4KiB of the address space, which is
quite practical, and it would allow combining 4 bits of one index byte with
all 8 bits of another. This is the only way I could find for this
architecture to do a lookup that depended on more than one byte. This is
quite indispensible for doing addition, since our approach depends on adding
parts of two different bytes together.

<p>The trick is, of course, another table: this time to generate the high
byte of a 16-bit indexed lookup. The observation is that since we want 12-bit
tables, only the low 4 bits of the high byte should be allowed to vary with
the index. Another 8-bit table can overwrite the high 4 bits of any byte with
the highest 4 bits of the table address. This allows the low 4 bits of any
byte to offset a lookup in a 4096-byte table.

<p>Addition tables like the one used here are not purely theoretical; the
approach was used in at least one production computer. The <a
href="https://en.wikipedia.org/wiki/IBM_1620">IBM 1620</a> was codenamed
CADET during devolpment; some in the user community suggested that this
acronym stood for "Can't Add, Doesn't Even Try". But, even machines like
these can't add, they sure do a good impression of those that can!

<div class="intro">
<h2>Implementation</h2>

<h3>Main Cycle</h3>
<pre>
-- Read instruction from SIO into R
  -- Begin read (0) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 0

  -- Begin read of IP (0) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  16 SIO = 0

  -- R sends instruction address (*IP) to SIO
  16 SIO.!HOLD = 0
  R.!CS = 1

  -- Begin write of IP (0) on R
  6 R.!CS = 0; SIO.!HOLD = 1; SIO = 0
  SIO = 1
  SIO = 0
  16 SIO = 0

  -- SIO sends instruction to R
  48 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1

-- Read value from SIO into R
  -- Begin read (0) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 0

  -- Begin read of SRC (2) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  14 SIO = 0
  SIO = 1
  SIO = 0

  -- R sends source address to SIO
  16 SIO.!HOLD = 0
  R.!CS = 1

  -- Begin write of VAL (6) on R
  6 R.!CS = 0; SIO.!HOLD = 1; SIO = 0
  SIO = 1
  SIO = 0
  13 SIO = 0
  2 SIO = 1
  SIO = 0

  -- SIO sends value to R
  8 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1

-- Write value from R to SIO
  -- Begin write (1) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 1

  -- Begin read of DST (4) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  13 SIO = 0
  SIO = 1
  2 SIO = 0

  -- R sends destination address and value to SIO
  24 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1
</pre>

In total, 240 cycles. Not too shabby!

<h3>Main Cycle for R.!CS</h3>
<pre>
  R.!CS = 1
  40 R.!CS = 0
  R.!CS = 1
  72 R.!CS = 0
  2 R.!CS = 1
  40 R.!CS = 0
  R.!CS = 1
  32 R.!CS = 0
  2 R.!CS = 1
  48 R.!CS = 0
  R.!CS = 1
</pre>

<h3>Main Cycle for !CS</h3>
<pre>
  114 !CS = 0
  !CS = 1
  74 !CS = 0
  !CS = 1
  49 !CS = 0
  !CS = 1
</pre>

<h3>Main Cycle for SIO</h3>
This includes the effect of the SIO.!HOLD signal, since this EEPROM is held for those cycles.
<pre>
  7 SIO = 0
  2 SIO = 1
  22 SIO = 0
  SIO = 1
  24 SIO = 0
  2 SIO = 1
  14 SIO = 0
  SIO = 1
  7 SIO = 0
  SIO = 1
  14 SIO = 0
  2 SIO = 1
  SIO = 0
  SIO = 1
  6 SIO = 0
  2 SIO = 1
  13 SIO = 0
  SIO = 1
  2 SIO = 0
</pre>

<h3>Main Cycle for SIO.!HOLD</h3>
<pre>
  25 SIO.!HOLD = 1
  17 SIO.!HOLD = 0
  24 SIO.!HOLD = 1
  49 SIO.!HOLD = 0
  25 SIO.!HOLD = 1
  17 SIO.!HOLD = 0
  24 SIO.!HOLD = 1
  9 SIO.!HOLD = 0
  25 SIO.!HOLD = 1
  25 SIO.!HOLD = 0
</pre>

<h3>Cycle Placement</h3>
<p>Since the main processor cycle takes 240 clock cycles, a 1024-bit EEPROM
can contain 4 main cycles. Since the SIO cycle is held for 117 of these
cycles, it only takes 123 cycles, and the 1024-bit EEPROM could
hypothetically hold 8 of them. However, in both cases there would be a
remainder of bits left over, since neither number evenly divides into 1024.
We need the two types of EEPROM to stay in sync with one another as these
remainders are handled.

<p>The 123 SIO cycles will fit 4 times into 512 bits, which allows the SIO
EEPROM to service 8 main processor cycles with SIO bits. There are 512 -
4*123 = 20 bits left over on the SIO EEPROM and 1024 - 4*240 = 64 bits left
over on the main EEPROMS. We thus need to hold the SIO eeprom for 64-20 = 44
cycles to sync the two EEPROMS up once every 4 cycles. These hold bits can be
placed anywhere in the empty region following the main cycle at the very end
of the SIO.!HOLD EEPROM.
</div>