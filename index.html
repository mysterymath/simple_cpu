<!doctype html>
<title>A Simple CPU</title>
<style>
    html {
        background-color: #002b36;
    }
    body {
        color: #839496;
	      font-family: Georgia, serif;
        line-height: 1.5;
        max-width: 60ch;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
	      font-family: sans-serif;
        line-height: normal;
    }
    p {
        text-align: justify;
    }
    .intro {
        break-inside: avoid;
    }
    code, pre {
      font-size: large;
    }
</style>

<div class="intro">
<h1>A Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that can be built? Inspired by <i>The Toaster Project</i>, I've
been exploring this question.
</div>

<p>Right off the bat, I realized that "simplest" is extremely subjective and
vague. Depending on how this word is interpreted, it could range anywhere
from manually wiring relays using copper wire to buying a CPU off the shelf.
For the game to be any fun, it'll need some rules.

<p>The rules can be whatever we like, but the goal of making a simplest CPU
will necessarily involve, at least in part, the most gratiutous allowable
abuse of the rules. Accordingly, the nature of the rules will control a great
deal of the project's nature. After carefully examining the consequences of
various rule sets, I've chosen the following:
<ul>
    <li>The CPU should be integrable in a "real system". Together they should
    be capable of doing usual computer things like I/O, addition,
    subtraction, etc.
    <li>Any parts of the CPU purchased from the store must not be specifically intended
    for inclusion in a CPU.
    <li>No FPGAs, CPLDs or the like in the CPU. Purchased parts must be
    limited in the sorts of functions they be made to directly compute.
    <li>The CPU should use as few components as possible.
    <li>The CPU should be responsible for the overall control of data
    processing in the system. While this rule is very vague, it's spirit
    rules out a class of cheats where a peripheral or the bus itself can be
    made so smart as to make the CPU too trivial.
    <li>The rest of the system will be played by a Raspberry PI's GPIO
    pins (3.3V).
</ul>
</div>

<div class="intro">
<h2>The Interface</h2>
<p>Before we delve into the design of such a CPU, what function must a CPU
actually perform in a system? The simpler the CPU's job can be made, the
simpler it's design can be. Well, in a modern computer architecture, a CPU
communicates with the rest of the computer via a bus. Over the bus, the CPU
requests information and delivers the results of computations to the
appropriate subsytems, as directed by the users program, stored in memory.
</div>

<p>The most important device sitting behind a bus is the main memory, so
let's start there. There are two operations the CPU could issue to the memory
via the bus: read and write. Both involve an address and one byte of data.
For a read, the CPU supplies the address to the bus, and the memory supplies
the data to the bus. For a write, the CPU supplies both the address and the
data to the bus.

<p>Some CPU designs have dedicated techniques for handling other non-memory
peripherals, but using memory-mapped I/O, essentially any hardware device can
be controlled with just the above two operations: read and write. Each device
connected to the CPU via the bus gets its own dedicated address range, and
exposes its functionality to the CPU in terms of reads from and writes to
those locations. The main memory chip only responds to address regions that
correspond to RAM; these and the memory regions for each device on the bus
are mutually exclusive.

<p>I like 8-bit systems with 16-bit addresses, so let's start there. This
gives us 64KB of addressable space over the bus, with 256 values per word.
Now, physically, how might the CPU request and deliver words with the rest of
the system? A simple bus design is the Serial Peripheral Interface (SPI). SPI
communicates data between a master (the CPU) and various chips using a clock
line (SCLK), a master serial output (MOSI), a master serial input (MISO), and
a chip select line (CS). The basic idea is that CS selects a chip, and the
master can send bits of data to it using MOSI, while the chip can send bits
of data to the master using MISO. The timing of the data is controlled by
SCLK. Once the operation is finished, CS deselects the chip.

<p>SPI can be used in a number of configurations. For reasons I'll get into
later, let's say the leading edge of the clock is the rising edge (CPOL=0).
Inputs are captured on the leading edge of the clock, while outputs are
changed on the trailing edge of the clock (CPHA=0). We'll also take CS to be
active low. Furthermore, we'll only use SPI in half-duplex mode, meaning only
one of MOSI and MISO can be driven at a time. They can thus share a wire; we
are using SPI in "three-wire mode."

<p>Let's diverge a bit from the usual way of using SPI and say that, instead
of one CS line per device, there's only one for the whole bus. Thus, CS
serves mostly to mark the beginning and end of operations. To select between
devices, we'll rely on the standard memory-mapped I/O approach. All devices
will listen to the bus for read and write instructions, but only the device
that "owns" the corresponding address will perform a write or answer a read.

<p>Let's also say that the SCLK signal generated by the CPU can have
considerable gaps in it where no transitions occur. This allows the CPU to
hold the bus when it need additional time to prepare for whatever it would be
expected to send or receive.

<p>So, we can take our CPU to have 6 connected pins: CLK, SCLK, MOSI/MISO,
CS, VCC and GND. SCLK is the SPI serial clock, which is an output for the
processor, while CLK is an input to the processor. SCLK's frequency will
usually be considerably less than CLK's, and may contain the aforementioned
hold gaps, while we'll take CLK to be a regular clock signal.

<p>Now that we have a "physical layer," we need a protocol to send over it.
We begin an operation by asserting CS. Next, a 0 or 1 is sent to indicate
whether the operation is a read or a write, respectively. write. Now, the
master can send the 16-bit address. If the operation was a read, the master
listens for the result. If the operation was a write, the master sends the
bits to write. For as long as CS is selected, bus will continue to send or
receive additional data, which will be considered to apply to successively
increasing addresses with a 64KiB wraparound. The operation ends when the CS
line is deselected; this must occur on an 8-bit boundary, and at least 8 bits
of data must be read/written.

<p>The above protocol is not original; it's a simplification of the interface
of a real Microchip SPI SRAM. Thus, there's good reason to think a practical
bus controller could implement it, and we needn't feel too bad coding up this
logic in Python in our Raspberry PI.

<div class="intro">
<h2>The Instruction Set</h2>
<p>Now that we have a mechanism for the processor to speak with the rest of
the system, what will it talk about? Traditionally, the processor reads an
instruction from the system, then does some arithmetic operation or other
internal processing. Some instructions may read values from the system, write
values to the system, or both.
<div class="intro">

<p>When designing the instruction set, how many instructions are necessary?
If the goal is to be as simple as possible, it turns out the answer is one.
There are a dazzing variety of "one instruction set computer" architectures,
where the computer has exactly one way of interacting with the rest of the
system, that it repeats indefinitely. Even so, given the magic of
Turing-completeness, the processor is able to simulate far more rich
instruction sets.

<p>Of all the Turing-complete instructions available, which should we select?
Our chosen bus suggests a natural answer. An OISC called "byte byte jump"
consists exclusively of the two basic operations: read and write. Couldn't be
simpler for our architecture.

<p>A byte byte jump instruction consists of the following 48-bits:
<ul>
    <li>A 16-bit source address
    <li>A 16-bit destination address
    <li>A 16-bit jump address
</ul>

<p>A CPU implementing byte byte jump would do the following repeatedly:
<ul>
    <li>Read the 48 bits at processors instruction pointer.
    <li>Read the 8 bits at the source address and then write them to the source address.
    <li>Change the processor's instruction pointer to the jump address.
</ul>

<p>That's it! A CPU capable of doing the above can compute any computable function.
</div>
</div>

<h3>The Synthesis of Addition</h3>
<p>To provide an intuition of how computation can be done with just a move
instruction, we will now synthesize an addition macro instruction from the
above. This section stands on its own; feel free to skip it if you believe that
the above instruction is both sufficient and practical.
</div>

<p>First, a few notational conventions. Let's refer to our base instruction as
follows:
<pre>
loc: MOV src dst [jmp] -- comment
</pre>

<p>The <code>jmp</code> argument is optional; if omitted, the address of the
next instruction. <code>loc</code> refers to the address of the instruction
itself. Comments begin with <code>--</code> and continue until the end of the
line. Temporary locations are indicated by <code>t[n]</code>, for some positive
integer <code>n</code> (optional). Locations and temporaries are considered
local to each macro instruction. We will avoid here specifying how the
instruction is laid out in RAM, but each part of an instruction at loc
can be referred to using loc.src, loc.dst, or loc.jmp.

<pre>
MOV_INDIR src lo dst [jmp]:
  -- *target = *(src &lt;&lt; 8 | *lo)
  MOV lo loc.src+1
  loc: MOV src dst jmp

MOV_INDIR16 hi lo dst [jmp]:
  -- *target = *(*hi &lt;&lt; 8 | *lo)
  MOV hi loc.src
  MOV lo loc.src+1
  loc: MOV 0xDEADBEEF dst jmp
</pre>

<p>Given indirect accesses, we can now construct and use tables. The contents
of various tables can be presented to the CPU by attaching ROM chips to the
system bus, or by loading them into RAM during a bootstrapping procedure.
Regardless, we can feel free to presume that whatever data we want can be
preloaded into RAM at whatever addresses we wish.

<p>Imagine we have a giant table that takes up the entire 64KB address space.
Such a table could be indexed by a pair of 8 bit values; one forming the high
byte of the value, and the other forming the low byte. In such a table, we
could just store the sum of the two indices; an indexed lookup into this
table would allow adding any two 8-bit values.

<p>Unfortunately, this wouldn't leave room in the address space for anything
else. But, we can instead consider a 4-bit sum table. The complete table of
4-bit vs 4-bit sums occupies only 256 addresses, and can be indexed using a
single byte. All such tables would need to be aligned to 256-bytes. Let's call
this table <code>sum4[256]</code>:

<pre>
ADD4 a dst [jmp]:
  -- *dst = (*a &gt;&gt; 4) + (*a &amp; 0x0F)
  MOV_INDIR sum4 a jmp
</pre>

<p>However, to use this, we need to be able to manipulate the high and low
4-bit portions of bytes. Let's build a handful of 4-bit manpulation
operators. Afterward, we'll see how they can be used to transform a 4-bit
table-based addition into a full 8-bit addition.

<p>First, let's build 4-bit left and right shift operators, using
<code>ls4[256]</code> and <code>rs4[256]</code> tables, respectively:

<pre>
LS4 src dst [jmp]:
  -- *dst = *src &lt;&lt; 4
  MOV_INDIR ls4 src jmp

RS4 src dst [jmp]:
  -- *dst = *src &gt;&gt; 4 &amp; 0x0F
  MOV_INDIR rs4 src jmp
</pre>

<p>Now, to use ADD4 to add the 4 low bits of one byte to the 4 low bits of
another, we need some way to merge together the low 4 bits of two bytes into
one. This would seem require a pair of 4-bit table lookups: merge4[16][16], but
our indirection trick only operates at a byte-level granularity.

<p>Say the first set of 4 bits was fixed, and we only needed to vary over the
second. We'd have 16 merge4 tables: merge4_0[256] to merge4_15[256]. Each of
them would store a value with 4 high bits of 0..15, and the low 4 bits of the
index. Now say we store these 16 tables consecutively from 0 to 15, and align
the whole 4096 bytes on a 4096-byte boundary. Now the 4 high bits of every
address in any of the tables are the same, and the low 4 bits of the high byte
selects the table. Thus, to find the right table location, we only need to
overwrite the 4 high bits of the first index with the 4 high bits of the table.
This we can do with yet another table, merge4[256].

<p>Putting it all together, we get the following:

<pre>
MERGE4 hi lo dst [jmp]:
  -- *dst = (*hi &amp; 0x0F) &lt;&lt; 4 | (*lo &amp; 0x0F)
  MOV_INDIR merge4 hi t
  MOV_INDIR16 t lo dst jmp
</pre>

<p>Now we can add the 4 low bits or the 4 high bits of two bytes:

<pre>
ADD4_LO a b dst [jmp]:
  -- *dst = (*a &amp; 0x0F) + (*b &amp; 0x0F)
  MERGE4 a b t
  ADD4 t dst jmp

ADD4_HI a b dst [jmp]:
  -- *dst = (*a &amp; 0xF0) &gt;&gt; 4 + (*b &amp; 0xF0) &gt;&gt; 4
  RS4 a t
  RS4 b t1
  ADD4_LO t t1 dst jmp
</pre>

<p>Finally, we can combine the two, producing the full 8-bit ADD:

<pre>
ADD a b dst [jmp]
  -- *dst = *a + *b
  ADD4_LO a b t -- low 4 bits = low addition
  RS4 t t1 -- low 4 bits = carry of the low addition
  ADD4_HI a b t2 -- low 4 bits = high addition without carry
  ADD4_LO t1 t2 t3 -- low 4 bits = high addition with carry
  MERGE4 t3 t dst jmp
</pre>

<div class="intro">
<h2>Implementation</h2>
<p>Here we take <code>&X</code> to be the address of the location
<code>X</code> in R. The instructions are laid out in RAM in the order jmp,
src, dst. * by itself indicates a repeat of the previous state.

<pre>
IP = 0
SRC = 2
DST = 4
VAL = 6

SIOOp(RAddr, Op, Body):
  -- Begins a SIO operation at the address 
  -- given by an address in R, executes the given body,
  -- then ends any outstanding operations. 

  -- Select R and send it read code (00000011).
  6 R.CS = 0; R = 0
  2 R = 1

  -- Write the address to R; begin read on SIO.
  15 R = IP
  R = IP; CS = 1; SIO = 0

  -- R sends the IP's address to SIO.
  16 R.CTRL = 0

  -- Note that R.CTRL = 0 in the body.
  Body()

  -- End the operation for both R and SIO
  R.CS = 1; CS = 0; R.CTRL = 1

WriteRFromSIO(RAddr,Size):
  -- Hold SIO and end any oustanding operation on R.
  R.CS = 1; HOLD = 1

  -- Select R and send it write code (00000010).
  6 R.CS = 0; R = 0; R.CTRL = 1
  R = 1
  R = 0

  -- Send the write address to R.
  16 R = RAddr

  -- The bus writes to R.
  Size R.CTRL = 0; HOLD = 0

Loop:
  SIOOp(IP, 0, { WriteRFromSIO(IP, 48) })
  SIOOp(SRC, 0, { WriteRFromSIO(VAL, 8) })

  -- Note: R will continue to output VAL after outputting DST,
  -- since VAL immediately follows DST
  SIOOp(DST, 1, { 8 * })
</pre>