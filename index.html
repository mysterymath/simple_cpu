<!doctype html>
<title>A Simple CPU</title>
<style>
    html {
        background-color: #002b36;
    }
    body {
        color: #839496;
	      font-family: Georgia, serif;
        line-height: 1.5;
        max-width: 60ch;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
	      font-family: sans-serif;
        line-height: normal;
    }
    p {
        text-align: justify;
    }
    .intro {
        break-inside: avoid;
    }
    code, pre {
      font-size: large;
    }
</style>

<div class="intro">
<h1>A Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that I can build? Inspired by <i><a
href="http://www.thetoasterproject.org">The Toaster Project</a></i>, I've
been exploring this question.
</div>

<p>"From scratch" and "simplest" are both rather vague. Depending on
interpretation, they could range anywhere from mining copper (hats off to
you, Toaster Guy) to buying a CPU off the shelf. If the task is too easy, it
won't feel satisfying. Too hard and it's not achievable at all. Some ground
rules seem in order.

<p>Making a "simplest" anything almost necessarily involves the most
gratiutous allowable abuse of the rules. Accordingly, the rules will control
a great deal of the project's nature. After carefully examining the
consequences of various rule sets, I've chosen the following:
<ul>
    <li>The CPU should be integrable in a "real system". Together they should
    be capable of doing usual computer things like I/O, addition,
    subtraction, etc.
    <li>Any parts of the CPU purchased from the store must not be specifically intended
    for inclusion in a CPU. This precludes purchasing ALUs and the like.
    <li>No FPGAs, CPLDs or the like in the CPU. Purchased parts must be
    limited in the sorts of functions they be made to directly compute.
    Otherwise this becomes "just another FPGA CPU project."
    <li>The CPU must be responsible for the overall control of the system.
    <li>The CPU should use as few components and wires as possible.
</ul>
</div>

<div class="intro">
<h2>Abstract CPU Design</h2>
<p>What exactly does a CPU do? Well, a CPU reads an instruction from the
system, then does whatever it says. Some instructions may involve obtaining
additional information from the system, delivering information to the system,
or both.
</div>

<div class="intro">
<h3>Communciations</h3>
<p>The CPU needs to be able to read/write main memory and to perform I/O. Via
the <a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">memory mapped
I/O</a> approach, certain address regions can be reserved for I/O devices,
with the rest mapping to main memory. I/O devices themselves answer reads and
writes for these regions, and various combinations of reads and writes
correspond to the avialable I/O operations. This allows one mechanism to be
used for all CPU/system communications. Nice and simple for the CPU (although
maybe less so for the I/O devices).
</div>

<p>The address space should be 8-bit byte-addressable, since that's long been
the standard. How big should addresses be? A multiple of 8 bits would allow
them to be stored in RAM without waste. 8-bit addresses would only allow 256
addressable bytes, but 16-bit addresses work just fine, allowing 64KiB of
address space. The addresses are stored big-endian, since that's what the
chips used in the implementation expect.

<div class="intro">
<h3>Instruction Set</h3>
<p> How many different kinds of operations does the CPU need to be able to
perform? If the goal is to be as simple as possible, only one. There are a
dazzling variety of <a
href="https://en.wikipedia.org/wiki/One_instruction_set_computer">one
instruction set computer</a> (OISC) architectures, where the computer has exactly
one way of interacting with the rest of the system. By the magic of
Turing-equivalency, any such processor is able to simulate far more rich
instruction sets, just by repeating that one interaction ad infinitum.
</div>

<p>Of all the OISC available, which is simplest to implement? Our chosen
communication scheme suggests a natural answer: <a
href="https://esolangs.org/wiki/ByteByteJump">byte byte jump</a>. This OISC
consists exclusively of the two basic communication operations: read and
write.

<p>A byte byte jump instruction contains the following 48-bits:
<ul>
    <li>A 16-bit source address
    <li>A 16-bit destination address
    <li>A 16-bit jump address
</ul>

<p>A CPU implementing byte byte jump would do the following repeatedly:
<ul>
    <li>Read the source, destination and jump addresses at the CPU's instruction pointer.
    <li>Read the byte at the source address and write it to the destination address.
    <li>Change the processor's instruction pointer to the jump address.
</ul>

<p>That's it! A CPU that can do the above can compute any computable
function. It's not an ivory tower theoretical "can" either; the reduction is
surprisingly practical (for a hilariously impractical value of practical).

<div class="intro">
<h2>Synthesizing Addition: <a href="https://en.wikipedia.org/wiki/IBM_1620">Can't Add, Doesn't Even Try</a></h2>
<p>To provide an intuition of how computation can be done with just a
glorified move instruction, I'll synthesize an 8-bit addition instruction
using only byte byte jump.

<p>How might we construct addition? Well, imagine we have a "giant" table
that takes up the entire 64KiB address space. Such a table could be indexed
by a pair of 8 bit values; one forming the high byte of the value, and the
other forming the low byte. In such a table, we could just store the sum of
the two indices; an indexed lookup into this table would allow adding any two
8-bit values.

<p>Unfortunately, this wouldn't leave room in the address space for anything
else. But this is just a matter of size. The complete table of 4-bit by 4-bit
sums occupies only 256 addresses. Call this table <code>sum4[256]</code>; it
contains the 8-bit result of adding the low 4 bits of the index to the high 4
bits. Assume that any such tables are preloaded into the address space as
part of the program.

<p>First, a few notational conventions. I'll refer to our base byte byte jump
instruction as follows:
<pre>
loc: MOV src dst [jmp] -- comment
</pre>

<p>The <code>jmp</code> argument is optional; if omitted, it implicitly
refers to the address of the next instruction. <code>loc</code> refers to the
address of the instruction itself. Comments begin with <code>--</code> and
continue until the end of the line. Temporary locations are indicated by
<code>t[n]</code>, for some positive integer <code>n</code> (optional).
Locations and temporaries are considered local to each macro instruction. I
will avoid here specifying how the instruction is laid out in RAM, but each
part of an instruction at <code>loc</code> can be referred to using
<code>loc.src</code>, <code>loc.dst</code>, or <code>loc.jmp</code>.

<p>Using this notation, I can now define an 8-bit table lookup. It consists
of two instructions. The first overwrites the low 8 bits of the second's
source address. Then, when the second executes, it loads from the offset
location within the table indicated by its fixed high byte.

<pre>
MOV_INDIR8 src lo dst [jmp]:
  -- *dst = *(src &amp; 0xFF00 | *lo)
  MOV lo loc.src+1
  loc: MOV src dst jmp
</pre>

<p>Using this lookup and the sum table, a 4-bit addition operation can be constructed:

<pre>
ADD4 a dst [jmp]:
  -- *dst = (*a &gt;&gt; 4) + (*a &amp; 0x0F)
  MOV_INDIR8 sum4 a jmp
</pre>

<p>A weird 4-bit addition isn't really the goal though; I want 8-bit
addition! How might we get there from here?

<pre>
TODO: Move into position
MOV_INDIR16 hi lo dst [jmp]:
  -- *target = *(*hi &lt;&lt; 8 | *lo)
  MOV hi loc.src
  MOV lo loc.src+1
  loc: MOV 0xDEADBEEF dst jmp
</pre>


<p>However, to use this, we need to be able to manipulate the high and low
4-bit portions of bytes. Let's build a handful of 4-bit manpulation
operators. Afterward, we'll see how they can be used to transform a 4-bit
table-based addition into a full 8-bit addition.

<p>First, let's build 4-bit left and right shift operators, using
<code>ls4[256]</code> and <code>rs4[256]</code> tables, respectively:

<pre>
LS4 src dst [jmp]:
  -- *dst = *src &lt;&lt; 4
  MOV_INDIR ls4 src jmp

RS4 src dst [jmp]:
  -- *dst = *src &gt;&gt; 4 &amp; 0x0F
  MOV_INDIR rs4 src jmp
</pre>

<p>Now, to use ADD4 to add the 4 low bits of one byte to the 4 low bits of
another, we need some way to merge together the low 4 bits of two bytes into
one. This would seem require a pair of 4-bit table lookups: merge4[16][16], but
our indirection trick only operates at a byte-level granularity.

<p>Say the first set of 4 bits was fixed, and we only needed to vary over the
second. We'd have 16 merge4 tables: merge4_0[256] to merge4_15[256]. Each of
them would store a value with 4 high bits of 0..15, and the low 4 bits of the
index. Now say we store these 16 tables consecutively from 0 to 15, and align
the whole 4096 bytes on a 4096-byte boundary. Now the 4 high bits of every
address in any of the tables are the same, and the low 4 bits of the high byte
selects the table. Thus, to find the right table location, we only need to
overwrite the 4 high bits of the first index with the 4 high bits of the table.
This we can do with yet another table, merge4[256].

<p>Putting it all together, we get the following:

<pre>
MERGE4 hi lo dst [jmp]:
  -- *dst = (*hi &amp; 0x0F) &lt;&lt; 4 | (*lo &amp; 0x0F)
  MOV_INDIR merge4 hi t
  MOV_INDIR16 t lo dst jmp
</pre>

<p>Now we can add the 4 low bits or the 4 high bits of two bytes:

<pre>
ADD4_LO a b dst [jmp]:
  -- *dst = (*a &amp; 0x0F) + (*b &amp; 0x0F)
  MERGE4 a b t
  ADD4 t dst jmp

ADD4_HI a b dst [jmp]:
  -- *dst = (*a &amp; 0xF0) &gt;&gt; 4 + (*b &amp; 0xF0) &gt;&gt; 4
  RS4 a t
  RS4 b t1
  ADD4_LO t t1 dst jmp
</pre>

<p>Finally, we can combine the two, producing the full 8-bit ADD:

<pre>
ADD a b dst [jmp]
  -- *dst = *a + *b
  ADD4_LO a b t -- low 4 bits = low addition
  RS4 t t1 -- low 4 bits = carry of the low addition
  ADD4_HI a b t2 -- low 4 bits = high addition without carry
  ADD4_LO t1 t2 t3 -- low 4 bits = high addition with carry
  MERGE4 t3 t dst jmp
</pre>

<div class="intro">
<h2>Implementation</h2>

<h3>Main Cycle</h3>
<pre>
-- Read instruction from SIO into R
  -- Begin read (0) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 0

  -- Begin read of IP (0) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  16 SIO = 0

  -- R sends instruction address (*IP) to SIO
  16 SIO.!HOLD = 0
  R.!CS = 1

  -- Begin write of IP (0) on R
  6 R.!CS = 0; SIO.!HOLD = 1; SIO = 0
  SIO = 1
  SIO = 0
  16 SIO = 0

  -- SIO sends instruction to R
  48 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1

-- Read value from SIO into R
  -- Begin read (0) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 0

  -- Begin read of SRC (2) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  14 SIO = 0
  SIO = 1
  SIO = 0

  -- R sends source address to SIO
  16 SIO.!HOLD = 0
  R.!CS = 1

  -- Begin write of VAL (6) on R
  6 R.!CS = 0; SIO.!HOLD = 1; SIO = 0
  SIO = 1
  SIO = 0
  13 SIO = 0
  2 SIO = 1
  SIO = 0

  -- SIO sends value to R
  8 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1

-- Write value from R to SIO
  -- Begin write (1) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 1

  -- Begin read of DST (4) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  13 SIO = 0
  SIO = 1
  2 SIO = 0

  -- R sends destination address and value to SIO
  24 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1
</pre>

In total, 240 cycles. Not too shabby!

<h3>Main Cycle for R.!CS</h3>
<pre>
  R.!CS = 1
  40 R.!CS = 0
  R.!CS = 1
  72 R.!CS = 0
  2 R.!CS = 1
  40 R.!CS = 0
  R.!CS = 1
  32 R.!CS = 0
  2 R.!CS = 1
  48 R.!CS = 0
  R.!CS = 1
</pre>

<h3>Main Cycle for !CS</h3>
<pre>
  114 !CS = 0
  !CS = 1
  74 !CS = 0
  !CS = 1
  49 !CS = 0
  !CS = 1
</pre>

<h3>Main Cycle for SIO</h3>
This includes the effect of the SIO.!HOLD signal, since this EEPROM is held for those cycles.
<pre>
  7 SIO = 0
  2 SIO = 1
  22 SIO = 0
  SIO = 1
  24 SIO = 0
  2 SIO = 1
  14 SIO = 0
  SIO = 1
  7 SIO = 0
  SIO = 1
  14 SIO = 0
  2 SIO = 1
  SIO = 0
  SIO = 1
  6 SIO = 0
  2 SIO = 1
  13 SIO = 0
  SIO = 1
  2 SIO = 0
</pre>

<h3>Main Cycle for SIO.!HOLD</h3>
<pre>
  25 SIO.!HOLD = 1
  17 SIO.!HOLD = 0
  24 SIO.!HOLD = 1
  49 SIO.!HOLD = 0
  25 SIO.!HOLD = 1
  17 SIO.!HOLD = 0
  24 SIO.!HOLD = 1
  9 SIO.!HOLD = 0
  25 SIO.!HOLD = 1
  25 SIO.!HOLD = 0
</pre>

<h3>Cycle Placement</h3>
<p>Since the main processor cycle takes 240 clock cycles, a 1024-bit EEPROM
can contain 4 main cycles. Since the SIO cycle is held for 117 of these
cycles, it only takes 123 cycles, and the 1024-bit EEPROM could
hypothetically hold 8 of them. However, in both cases there would be a
remainder of bits left over, since neither number evenly divides into 1024.
We need the two types of EEPROM to stay in sync with one another as these
remainders are handled.

<p>The 123 SIO cycles will fit 4 times into 512 bits, which allows the SIO
EEPROM to service 8 main processor cycles with SIO bits. There are 512 -
4*123 = 20 bits left over on the SIO EEPROM and 1024 - 4*240 = 64 bits left
over on the main EEPROMS. We thus need to hold the SIO eeprom for 64-20 = 44
cycles to sync the two EEPROMS up once every 4 cycles. These hold bits can be
placed anywhere in the empty region following the main cycle at the very end
of the SIO.!HOLD EEPROM.