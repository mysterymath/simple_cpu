<!doctype html>
<title>A Very Simple CPU</title>
<style>
    html {
        background-color: #002b36;
        color: #839496;
    }
    body {
        max-width: 75ch;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
    }
    p {
        text-align: justify;
    }
    p, ul {
        font-size: large;
    }
</style>
<h1>A Very Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that can be built? Inspired by <i>The Toaster Project</i>, I've
been exploring this question.

<p>Right off the bat, I realized that "simplest" is extremely subjective and
vague. Depending on how this word is interpreted, it could range anywhere
from manually wiring relays using copper wire to buying a CPU off the shelf.
For the game to be any fun, it'll need some rules.

<p>If the rules are too strict, the project will be too difficult. If the
rules are too lenient, the project will be feel like cheating. Let's start on
the difficult side of things.

<h2>A CPU From Scratch</h2>
<p>To build a CPU from scratch, you must first create the universe.
Definitely too difficult. Let's assume a preexisting Earth. To create a CPU,
at the very least I'd need some kind of switching element. This means winding
relays from copper wire, blowing glass vaccuum tubes, or using sophisitical
chemical processes to manufacture semiconductors. Also too difficult. Now let's
vaccilate back to too easy.

<h2>A CPU From The Store</h2>
<p>The easiest way to make a CPU is to deposit a small amount of money into a
societal system that manufactures CPU's at scale, in exchange for one CPU's
worth of output. This is usually called "buying one." This is, of course, boring.

<p>A slightly less easy way to make a CPU is to purchase a FPGA or CPLD that
can be reconfigured into nearly any desired digital circuit. A CPU design
could then be downloaded from the Internet onto the chip. This is only
slightly more interesting than buying a CPU. I could write the configuration
myself, but this still woudln't feel like making a CPU. A FPGA is
specifically designed to be turned into something like a CPU; it's just a bit
too far from "from scratch" for my taste. Similar logic applies to pre-built
ALUs and the like.

<h2>A CPU From Non-CPU</h2>
<p>So, making the logic elements from scratch is too hard, so I'll have to buy
them. But buying a FPGA is too easy, since it's designed to become any
circuit you like, including a CPU. This suggests the following rules:

<ul>
    <li>Any parts purchased from the store must not be specifically intended
        for inclusion in a CPU.
    <li>No FPGAs, CPLDs or the like. Any parts purchased must be limited in
        the sorts of functions they can be made to compute.
    <li>The CPU should use as few components as possible.
    <li>The CPU should be integrable in a "real system", capable of doing
        usual computer things like I/O. The real system is not constrained by
        these rules.
</ul>

<h2>The Interface</h2>
<p>Before we delve into the design of such a CPU, what function must a CPU
actually perform in a system? The simpler the CPU's job can be made, the
simpler it's design can be. Well, in a modern computer architecture, a CPU
communicates with the rest of the computer via a bus. Modern implementations
of these busses are quite complex, so we'll use a far simpler model. Instead
of getting into the detailed design of such a bus, let's treat it a bit
abstractly. The details will resolve themselves with time.

<p>The most important device sitting behind a bus is the main memory, so
let's start there. There are two operations the CPU could issue to the memory
via the bus: read and write. Both involve an address and one byte of data.
For a read, the CPU supplies the address to the bus, and the memory supplies
the data to the bus. For a write, the CPU supplies both the address and the
data to the bus.

<p>Some CPU designs have dedicated techniques for handling other non-memory
peripherals, but using memory-mapped I/O, essentially any hardware device can
be controlled with just the above two operations: read and write. Each device
connected to the CPU via the bus gets its own dedicated address range, and
exposes its functionality to the CPU in terms of reads from and writes to
those locations. The main memory chip only responds to address regions that
correspond to RAM; these and the memory regions for each device on the bus
are mutually exclusive.

<h2>The Memory and Bus</h2>
<p>Since the memory is the most important (and only necessary) device on the
bus, we can let it dictate the bus's design. If we use 16-bit addresses, then
we have 64KB of addressable space to work with on the bus. Let's start
looking for a memory chip of that size.

<p>There are two main types of modern memory suitable for main system RAM:
SRAM and DRAM. DRAM is cheaper and has far more storage available, but it
must be refreshed periodically or all the data will leak out of it (hence
Dynamic RAM). SRAM (Static RAM) is going to be far easier to work with, since
it will keep its contents so long as power is supplied, with no additional
support required. So, let's look for the cheapest available 64KB SRAM.
Through-hole, so we can work on a breadboard. To Mouser!

<p>For main memory, I've selected the <a
href="https://www.microchip.com/wwwproducts/en/23LC512">Microchip
23LC512-I/P</a> (<a
href="https://www.mouser.com/datasheet/2/268/20005155B-1512297.pdf">Datasheet</a>).
This is a 64 KB SRAM capable of operating at between 2.5-5.5V and at up to 20
MHz. There's almost nothing up my sleeve with this selection: it was the
second cheapest chip with the criterion given above. The cheapest was the
same chip, but running at 1.8 V; the selected version can just be used more
easily with a Raspberry PI (3.3V)V.

<p>Though this chip has 64KB of RAM, in 8 bit bytes, with a 16 bit address
space, it has only 8 pins! Two of the pins are voltage and ground, another
one will be held low in our usage, leaving only 5 meaniful pins. Well, the
chip is SPI, and data is accessed in a serial fashion. While I initially
recoiled at the complexity of implementing a serial protocol to speak to a
memory chip, in retrospect it's actually quite convenient; almost no wiring
is needed to use the chip!

<p>So, let us design our bus around this mighty chip. The five useful pins are
SCK, SI, SO, CS, and HOLD. SCK is simply a clock signal, and SI and SO are
the input and output pins. When SCK goes from low to high, the chip measures
SI. When SCK later goes from high to low, it may change SO. HOLD should
normally be kept high, but it can be driven low to pause the chip. This
disables SO and causes the chip to ignore clock edges. CS is kept high by
default, and is brought low for the duration of a transaction with the chip.
It is brought high again to end the transaction.

<p>The chip has a number of modes; from here on, we'll be discussing only one of
them. The means to get the chip into this mode will be left til the
discussion of bootstrapping.

<p>The chip has two essential transactions for our purposes, just like the bus:
read and write. To write, the following values are clocked into SI:
0b00000011, then the 16-bit address, then as much data as desired, in
multiples of 8 bits. After the first byte, the chip will continue to write SI
to successive addresses until CS is brought high to end the write. Similarly,
a read consists of 0b00000010, then the 16-bit address. After this, the chip
stops caring about the contents of SI, and sets SO to the value at this
address and successive addresses, until CS is brought high to end the read.

<p>This seems like a perfectly servicable architecture for our bus as well, with
one slight caveat. The memory chip will always respond to reads, no matter
the address, which would not give other peripherals the opportunity to speak
up. To avoid this, a simple bus controller could watch the input for read
patterns and deselect the memory chip whenever an I/O address is specified.
This cancels the memory read and prevents the chip from speaking on the bus.