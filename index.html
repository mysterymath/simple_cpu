<!doctype html>
<title>A Simple CPU</title>
<style>
    html {
        background-color: #002b36;
        color: #839496;
    }
    body {
        column-width: 75ch;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
    }
    p {
        text-align: justify;
    }
    .intro {
        break-inside: avoid;
    }
</style>
<div class="intro">
<h1>A Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that can be built? Inspired by <i>The Toaster Project</i>, I've
been exploring this question.
</div>

<p>Right off the bat, I realized that "simplest" is extremely subjective and
vague. Depending on how this word is interpreted, it could range anywhere
from manually wiring relays using copper wire to buying a CPU off the shelf.
For the game to be any fun, it'll need some rules.

<p>If the rules are too strict, the project will be too difficult. If the
rules are too lenient, the project will be feel like cheating. Let's start on
the difficult side of things.

<div class="intro">
<h2>A CPU from Scratch</h2>
<p>To build a CPU from scratch, you must first create the universe. Definitely
too difficult. Let's assume a preexisting Earth. To create a CPU, at the very
least I'd need some kind of switching element. This means winding relays from
copper wire, blowing glass vaccuum tubes, or using sophisiticated chemical
processes to manufacture semiconductors. Also too difficult. So, we're going to
have to buy our switching elements, at the very least. But if we can go buy
things, it seems like that can devolve very quickly.
</div>

<div class="intro">
<h2>A CPU from the Store</h2>
<p>The easiest way to make a CPU is to deposit a small amount of money into a
societal system that manufactures CPU's at scale, in exchange for one CPU's
worth of output. This is usually called "buying one." This is, of course, boring.
</div>

<p>A less easy way to make a CPU is to purchase a FPGA or CPLD that can be
reconfigured into nearly any desired digital circuit. A CPU design could then
be downloaded from the Internet onto the chip. This is only slightly more
interesting than buying a CPU. I could write the configuration myself, but this
still woudln't feel like making a CPU. A FPGA is specifically designed to be
turned into something like a CPU; it's just a bit too far from "from scratch"
for my taste. Similar logic applies to pre-built ALUs and the like.

<div class="intro">
<h2>A Simple CPU</h2>
<p>So, making the logic elements from scratch is too hard, so I'll have to buy
them. But buying a FPGA is too easy, since it's designed to become any
circuit you like, including a CPU. This suggests the following rules:

<ul>
    <li>Any parts purchased from the store must not be specifically intended
        for inclusion in a CPU.
    <li>No FPGAs, CPLDs or the like. Any parts purchased must be limited in
        the sorts of functions they can be made to compute.
    <li>The CPU should use as few components as possible.
    <li>The CPU should be integrable in a "real system", capable of doing
        usual computer things like I/O. The real system is not constrained by
        these rules.
</ul>
</div>

<div class="intro">
<h2>The Interface</h2>
<p>Before we delve into the design of such a CPU, what function must a CPU
actually perform in a system? The simpler the CPU's job can be made, the
simpler it's design can be. Well, in a modern computer architecture, a CPU
communicates with the rest of the computer via a bus. Modern implementations
of these busses are quite complex, so we'll use a far simpler model. Instead
of getting into the detailed design of such a bus, let's treat it a bit
abstractly. The details will resolve themselves with time.
</div>

<p>The most important device sitting behind a bus is the main memory, so
let's start there. There are two operations the CPU could issue to the memory
via the bus: read and write. Both involve an address and one byte of data.
For a read, the CPU supplies the address to the bus, and the memory supplies
the data to the bus. For a write, the CPU supplies both the address and the
data to the bus.

<p>Some CPU designs have dedicated techniques for handling other non-memory
peripherals, but using memory-mapped I/O, essentially any hardware device can
be controlled with just the above two operations: read and write. Each device
connected to the CPU via the bus gets its own dedicated address range, and
exposes its functionality to the CPU in terms of reads from and writes to
those locations. The main memory chip only responds to address regions that
correspond to RAM; these and the memory regions for each device on the bus
are mutually exclusive.

<div class="intro">
<h2>The Memory and Bus</h2>
<p>Since the memory is the most important (and only necessary) device on the
bus, we can let it dictate the bus's design. If we use 16-bit addresses, then
we have 64KB of addressable space to work with on the bus. Let's start
looking for a memory chip of that size.
</div>

<p>There are two main types of modern memory suitable for main system RAM:
SRAM and DRAM. DRAM is cheaper and has far more storage available, but it
must be refreshed periodically or all the data will leak out of it (hence
Dynamic RAM). SRAM (Static RAM) is going to be far easier to work with, since
it will keep its contents so long as power is supplied, with no additional
support required. So, let's look for the cheapest available 64KB SRAM.
Through-hole, so we can work on a breadboard. To Mouser!

<p>For main memory, I've selected the <a
href="https://www.microchip.com/wwwproducts/en/23LC512">Microchip
23LC512-I/P</a> (<a
href="https://www.mouser.com/datasheet/2/268/20005155B-1512297.pdf">Datasheet</a>).
This is a 64 KB SRAM capable of operating at between 2.5-5.5V and at up to 20
MHz. There's almost nothing up my sleeve with this selection: it was the
second cheapest chip with the criterion given above. The cheapest was the
same chip, but running at 1.8 V; the selected version can just be used more
easily with a Raspberry PI (3.3V).

<p>Though this chip has 64KB of RAM, in 8 bit bytes, with a 16 bit address
space, it has only 8 pins! Two of the pins are voltage and ground, another
one will be held low in our usage, leaving only 5 meaniful pins. Well, the
chip is SPI, and data is accessed in a serial fashion. While I initially
recoiled at the complexity of implementing a serial protocol to speak to a
memory chip, in retrospect it's actually quite convenient; almost no wiring
is needed to use the chip!

<p>So, let us design our bus around this mighty chip. The five useful pins are
SCK, SI, SO, CS, and HOLD. SCK is simply a clock signal, and SI and SO are
the input and output pins. When SCK goes from low to high, the chip measures
SI. When SCK later goes from high to low, it may change SO. HOLD should
normally be kept high, but it can be driven low to pause the chip. This
disables SO and causes the chip to ignore clock edges. CS is kept high by
default, and is brought low for the duration of a transaction with the chip.
It is brought high again to end the transaction.

<p>The chip has a number of modes; from here on, we'll be discussing only one of
them. The means to get the chip into this mode will be left til the
discussion of bootstrapping.

<p>The chip has two essential transactions for our purposes, just like the bus:
read and write. To write, the following values are clocked into SI:
00000011, then the 16-bit address, then as much data as desired, in
multiples of 8 bits. After the first byte, the chip will continue to write SI
to successive addresses until CS is brought high to end the write. Similarly,
a read consists of 00000010, then the 16-bit address. After this, the chip
stops caring about the contents of SI, and sets SO to the value at this
address and successive addresses, until CS is brought high to end the read.

<p>This seems like a perfectly servicable architecture for our bus as well, with
one slight caveat. The memory chip will always respond to reads, no matter
the address, which would not give other peripherals the opportunity to speak
up. To avoid this, a simple bus controller could watch the input for read
patterns and deselect the memory chip whenever an I/O address is specified.
This cancels the memory read and prevents the chip from speaking on the bus.

<div class="intro">
<h2>The Instruction Set</h2>
<p>Now that we have a mechanism for the processor to speak with the rest of
the system, what will it talk about? Traditionally, the processor reads an
instruction from the system, then does some arithmetic operation or other
internal processing. Some instructions may read values from the system, write
values to the system, or both.
<div class="intro">

<p>When designing the instruction set, how many instructions are necessary?
If the goal is to be as simple as possible, it turns out the answer is one.
There are a dazzing variety of "one instruction set computer" architectures,
where the computer has exactly one way of interacting with the rest of the
system, that it repeats indefinitely. Even so, given the magic of
Turing-completeness, the processor is able to simulate far more rich
instruction sets.

<p>Of all the Turing-complete instructions available, which should we select?
Our chosen bus suggests a natural answer. An OISC called "byte byte jump"
consists exclusively of the two basic operations: read and write. Couldn't be
simpler for our architecture.

<p>A byte byte jump instruction consists of the following 48-bits:
<ul>
    <li>A 16-bit source address
    <li>A 16-bit destination address
    <li>A 16-bit jump address
</ul>

<p>A CPU implementing byte byte jump would do the following repeatedly:
<ul>
    <li>Read the 48 bits at processors instruction pointer.
    <li>Read the 8 bits at the source address and then write them to the source address.
    <li>Change the processor's instruction pointer to the jump address.
</ul>

<p>That's it! A CPU capable of doing the above can compute any computable function.
</div>
</div>

<h3>The Synthesis of Addition</h3>
<p>To provide an intuition of how computation can be done with just a move
instruction, we will now synthesize an addition macro instruction from the
above. This section stands on its own; feel free to skip it if you believe that
the above instruction is both sufficient and practical.
</div>

<p>First, a few notational conventions. Let's refer to our base instruction as
follows:
<p><code>loc: MOV src dst [jmp] -- comment</code>

<p>The <code>jmp</code> argument is optional; if omitted, the address of the
next instruction. <code>loc</code> refers to the address of the instruction
itself. Comments begin with <code>--</code> and continue until the end of the
line. Temporary locations are indicated by <code>t[n]</code>, for some positive
integer <code>n</code> (optional). Locations and temporaries are considered
local to each macro instruction.

<p>We can use the fact that the instructions are stored in RAM to synthesize
an indirect move. We just overwrite part or all of the source location with
the index:

<pre>
MOV_INDIR src lo dst [jmp]:
  -- *target = *(src &lt;&lt; 8 | *lo); goto jmp;
  MOV lo loc+1
  loc: MOV src dst jmp

MOV_INDIR16 hi lo dst [jmp]:
  -- *target = *(*hi &lt;&lt; 8 | *lo); goto jmp;
  MOV hi loc
  MOV lo loc+1
  loc: MOV src dst jmp
</pre>

<p>Given indirect accesses, we can now construct and use tables. The contents
of various tables can be presented to the CPU by attaching ROM chips to the
system bus, or by loading them into RAM during a bootstrapping procedure.
Regardless, we can feel free to presume that whatever data we want can be
preloaded into RAM at whatever addresses we wish.

<p>Imagine we have a giant table that takes up the entire 64KB address space.
Such a table could be indexed by a pair of 8 bit values; one forming the high
byte of the value, and the other forming the low byte. In such a table, we
could just store the sum of the two indices; an indexed lookup into this
table would allow adding any two 8-bit values.

<p>Unfortunately, this wouldn't leave room in the address space for anything
else. But, we can instead consider a 4-bit sum table. The complete table of
4-bit vs 4-bit sums occupies only 256 addresses, and can be indexed using a
single byte. All such tables would need to be aligned to 256-bytes. Let's call
this table <code>sum4[256]</code>:

<pre>
ADD4 a dst [jmp]:
  -- *dst = (*a &gt;&gt; 4) + (*a &amp; 0x0F); goto jmp;
  MOV_INDIR sum4 a jmp
</pre>

<p>However, to use this, we need to be able to manipulate the high and low
4-bit portions of bytes. Let's build a handful of 4-bit manpulation
operators. Afterward, we'll see how they can be used to transform a 4-bit
table-based addition into a full 8-bit addition.

<p>First, let's build 4-bit left and right shift operators, using
<code>ls4[256]</code> and <code>rs4[256]</code> tables, respectively:

<pre>
LS4 src dst [jmp]:
  -- *dst = *src &lt;&lt; 4; goto jmp;
  MOV_INDIR ls4 src jmp

RS4 src dst [jmp]:
  -- *dst = *src &gt;&gt; 4 &amp; 0x0F; goto jmp;
  MOV_INDIR rs4 src jmp
</pre>

<p>Now, to use ADD4 to add the 4 low bits of one byte to the 4 low bits of
another, we need some way to merge together the low 4 bits of two bytes into
one. This would seem require a pair of 4-bit table lookups: merge4[16][16], but
our indirection trick only operates at a byte-level granularity.

<p>Say the first set of 4 bits was fixed, and we only needed to vary over the
second. We'd have 16 merge4 tables: merge4_0[256] to merge4_15[256]. Each of
them would store a value with 4 high bits of 0..15, and the low 4 bits of the
index. Now say we store these 16 tables consecutively from 0 to 15, and align
the whole 4096 bytes on a 4096-byte boundary. Now the 4 high bits of every
address in any of the tables are the same, and the low 4 bits of the high byte
selects the table. Thus, to find the right table location, we only need to
overwrite the 4 high bits of the first index with the 4 high bits of the table.
This we can do with yet another table, merge4[256].

<p>Putting it all together, we get the following:

<pre>
MERGE4 hi lo dst [jmp]:
  -- *dst = (*hi &amp; 0x0F) &lt;&lt; 4 | (*lo &amp; 0x0F); goto jmp;
  MOV_INDIR merge4 hi t
  MOV_INDIR16 t lo dst jmp
</pre>

<p>Now we can add the 4 low bits or the 4 high bits of two bytes:

<pre>
ADD4_LO a b dst [jmp]:
  -- *dst = (*a &amp; 0x0F) + (*b &amp; 0x0F); goto jmp;
  MERGE4 a b t
  ADD4 t dst jmp

ADD4_HI a b dst [jmp]:
  -- *dst = (*a &amp; 0xF0) &gt;&gt; 4 + (*b &amp; 0xF0) &gt;&gt; 4; goto jmp;
  RS4 a t
  RS4 b t1
  ADD4_LO t t1 dst jmp
</pre>

<p>Finally, we can combine the two, producing the full 8-bit ADD:

<pre>
ADD a b dst [jmp]
  -- *dst = *a + *b; goto jmp;
  ADD4_LO a b t -- low 4 bits = low addition
  RS4 t t1 -- low 4 bits = carry of the low addition
  ADD4_HI a b t2 -- low 4 bits = high addition without carry
  ADD4_LO t1 t2 t3 -- low 4 bits = high addition with carry
  MERGE4 t3 t dst jmp
