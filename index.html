<!doctype html>
<title>A Simple CPU</title>
<style>
    html {
        background-color: #002b36;
    }
    body {
        color: #839496;
	      font-family: Georgia, serif;
        line-height: 1.5;
        max-width: 60ch;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
	      font-family: sans-serif;
        line-height: normal;
    }
    p {
        text-align: justify;
    }
    .intro {
        break-inside: avoid;
    }
    code, pre {
      font-size: large;
    }
</style>

<div class="intro">
<h1>A Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that can be built? Inspired by <i>The Toaster Project</i>, I've
been exploring this question.
</div>

<p>Right off the bat, I realized that "simplest" is extremely subjective and
vague. Depending on how this word is interpreted, it could range anywhere
from manually wiring relays using copper wire to buying a CPU off the shelf.
For the game to be any fun, it'll need some rules.

<p>The rules can be whatever we like, but the goal of making a simplest CPU
will necessarily involve, at least in part, the most gratiutous allowable
abuse of the rules. Accordingly, the nature of the rules will control a great
deal of the project's nature. After carefully examining the consequences of
various rule sets, I've chosen the following:
<ul>
    <li>The CPU should be integrable in a "real system". Together they should
    be capable of doing usual computer things like I/O, addition,
    subtraction, etc.
    <li>Any parts of the CPU purchased from the store must not be specifically intended
    for inclusion in a CPU.
    <li>No FPGAs, CPLDs or the like in the CPU. Purchased parts must be
    limited in the sorts of functions they be made to directly compute.
    <li>The CPU should use as few components as possible.
    <li>The CPU should be responsible for the overall control of data
    processing in the system. While this rule is very vague, it's spirit
    rules out a class of cheats where a peripheral or the bus itself can be
    made so smart as to make the CPU too trivial.
    <li>The rest of the system will be played by a Raspberry PI's GPIO
    pins (3.3V).
</ul>
</div>

<div class="intro">
<h2>The Instruction Set</h2>
<p>Now that we have a mechanism for the processor to speak with the rest of
the system, what will it talk about? Traditionally, the processor reads an
instruction from the system, then does some arithmetic operation or other
internal processing. Some instructions may read values from the system, write
values to the system, or both.
<div class="intro">

<p>When designing the instruction set, how many instructions are necessary?
If the goal is to be as simple as possible, it turns out the answer is one.
There are a dazzing variety of "one instruction set computer" architectures,
where the computer has exactly one way of interacting with the rest of the
system, that it repeats indefinitely. Even so, given the magic of
Turing-completeness, the processor is able to simulate far more rich
instruction sets.

<p>Of all the Turing-complete instructions available, which should we select?
Our chosen bus suggests a natural answer. An OISC called "byte byte jump"
consists exclusively of the two basic operations: read and write. Couldn't be
simpler for our architecture.

<p>A byte byte jump instruction consists of the following 48-bits:
<ul>
    <li>A 16-bit source address
    <li>A 16-bit destination address
    <li>A 16-bit jump address
</ul>

<p>A CPU implementing byte byte jump would do the following repeatedly:
<ul>
    <li>Read the 48 bits at processors instruction pointer.
    <li>Read the 8 bits at the source address and then write them to the source address.
    <li>Change the processor's instruction pointer to the jump address.
</ul>

<p>That's it! A CPU capable of doing the above can compute any computable function.
</div>
</div>

<h3>The Synthesis of Addition</h3>
<p>To provide an intuition of how computation can be done with just a move
instruction, we will now synthesize an addition macro instruction from the
above. This section stands on its own; feel free to skip it if you believe that
the above instruction is both sufficient and practical.
</div>

<p>First, a few notational conventions. Let's refer to our base instruction as
follows:
<pre>
loc: MOV src dst [jmp] -- comment
</pre>

<p>The <code>jmp</code> argument is optional; if omitted, the address of the
next instruction. <code>loc</code> refers to the address of the instruction
itself. Comments begin with <code>--</code> and continue until the end of the
line. Temporary locations are indicated by <code>t[n]</code>, for some positive
integer <code>n</code> (optional). Locations and temporaries are considered
local to each macro instruction. We will avoid here specifying how the
instruction is laid out in RAM, but each part of an instruction at loc
can be referred to using loc.src, loc.dst, or loc.jmp.

<pre>
MOV_INDIR src lo dst [jmp]:
  -- *target = *(src &lt;&lt; 8 | *lo)
  MOV lo loc.src+1
  loc: MOV src dst jmp

MOV_INDIR16 hi lo dst [jmp]:
  -- *target = *(*hi &lt;&lt; 8 | *lo)
  MOV hi loc.src
  MOV lo loc.src+1
  loc: MOV 0xDEADBEEF dst jmp
</pre>

<p>Given indirect accesses, we can now construct and use tables. The contents
of various tables can be presented to the CPU by attaching ROM chips to the
system bus, or by loading them into RAM during a bootstrapping procedure.
Regardless, we can feel free to presume that whatever data we want can be
preloaded into RAM at whatever addresses we wish.

<p>Imagine we have a giant table that takes up the entire 64KB address space.
Such a table could be indexed by a pair of 8 bit values; one forming the high
byte of the value, and the other forming the low byte. In such a table, we
could just store the sum of the two indices; an indexed lookup into this
table would allow adding any two 8-bit values.

<p>Unfortunately, this wouldn't leave room in the address space for anything
else. But, we can instead consider a 4-bit sum table. The complete table of
4-bit vs 4-bit sums occupies only 256 addresses, and can be indexed using a
single byte. All such tables would need to be aligned to 256-bytes. Let's call
this table <code>sum4[256]</code>:

<pre>
ADD4 a dst [jmp]:
  -- *dst = (*a &gt;&gt; 4) + (*a &amp; 0x0F)
  MOV_INDIR sum4 a jmp
</pre>

<p>However, to use this, we need to be able to manipulate the high and low
4-bit portions of bytes. Let's build a handful of 4-bit manpulation
operators. Afterward, we'll see how they can be used to transform a 4-bit
table-based addition into a full 8-bit addition.

<p>First, let's build 4-bit left and right shift operators, using
<code>ls4[256]</code> and <code>rs4[256]</code> tables, respectively:

<pre>
LS4 src dst [jmp]:
  -- *dst = *src &lt;&lt; 4
  MOV_INDIR ls4 src jmp

RS4 src dst [jmp]:
  -- *dst = *src &gt;&gt; 4 &amp; 0x0F
  MOV_INDIR rs4 src jmp
</pre>

<p>Now, to use ADD4 to add the 4 low bits of one byte to the 4 low bits of
another, we need some way to merge together the low 4 bits of two bytes into
one. This would seem require a pair of 4-bit table lookups: merge4[16][16], but
our indirection trick only operates at a byte-level granularity.

<p>Say the first set of 4 bits was fixed, and we only needed to vary over the
second. We'd have 16 merge4 tables: merge4_0[256] to merge4_15[256]. Each of
them would store a value with 4 high bits of 0..15, and the low 4 bits of the
index. Now say we store these 16 tables consecutively from 0 to 15, and align
the whole 4096 bytes on a 4096-byte boundary. Now the 4 high bits of every
address in any of the tables are the same, and the low 4 bits of the high byte
selects the table. Thus, to find the right table location, we only need to
overwrite the 4 high bits of the first index with the 4 high bits of the table.
This we can do with yet another table, merge4[256].

<p>Putting it all together, we get the following:

<pre>
MERGE4 hi lo dst [jmp]:
  -- *dst = (*hi &amp; 0x0F) &lt;&lt; 4 | (*lo &amp; 0x0F)
  MOV_INDIR merge4 hi t
  MOV_INDIR16 t lo dst jmp
</pre>

<p>Now we can add the 4 low bits or the 4 high bits of two bytes:

<pre>
ADD4_LO a b dst [jmp]:
  -- *dst = (*a &amp; 0x0F) + (*b &amp; 0x0F)
  MERGE4 a b t
  ADD4 t dst jmp

ADD4_HI a b dst [jmp]:
  -- *dst = (*a &amp; 0xF0) &gt;&gt; 4 + (*b &amp; 0xF0) &gt;&gt; 4
  RS4 a t
  RS4 b t1
  ADD4_LO t t1 dst jmp
</pre>

<p>Finally, we can combine the two, producing the full 8-bit ADD:

<pre>
ADD a b dst [jmp]
  -- *dst = *a + *b
  ADD4_LO a b t -- low 4 bits = low addition
  RS4 t t1 -- low 4 bits = carry of the low addition
  ADD4_HI a b t2 -- low 4 bits = high addition without carry
  ADD4_LO t1 t2 t3 -- low 4 bits = high addition with carry
  MERGE4 t3 t dst jmp
</pre>

<div class="intro">
<h2>Implementation</h2>

<h3>Main Cycle</h3>
<pre>
-- Read instruction from SIO into R
  -- Begin read (0) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 0

  -- Begin read of IP (0) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  16 SIO = 0

  -- R sends instruction address (*IP) to SIO
  16 SIO.!HOLD = 0
  R.!CS = 1

  -- Begin write of IP (0) on R
  6 R.!CS = 0; SIO.!HOLD = 1; SIO = 0
  SIO = 1
  SIO = 0
  16 SIO = 0

  -- SIO sends instruction to R
  48 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1

-- Read value from SIO into R
  -- Begin read (0) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 0

  -- Begin read of SRC (2) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  14 SIO = 0
  SIO = 1
  SIO = 0

  -- R sends source address to SIO
  16 SIO.!HOLD = 0
  R.!CS = 1

  -- Begin write of VAL (6) on R
  6 R.!CS = 0; SIO.!HOLD = 1; SIO = 0
  SIO = 1
  SIO = 0
  13 SIO = 0
  2 SIO = 1
  SIO = 0

  -- SIO sends value to R
  8 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1

-- Write value from R to SIO
  -- Begin write (1) on SIO
  !CS = 0; SIO.!HOLD = 1; SIO = 1

  -- Begin read of DST (4) on R
  6 R.!CS = 0; SIO = 0
  2 SIO = 1
  13 SIO = 0
  SIO = 1
  2 SIO = 0

  -- R sends destination address and value to SIO
  24 SIO.!HOLD = 0
  R.!CS = 1; !CS = 1
</pre>

In total, 240 cycles. Not too shabby!

<h3>Main Cycle for R.!CS</h3>
<pre>
  R.!CS = 1
  40 R.!CS = 0
  R.!CS = 1
  72 R.!CS = 0
  2 R.!CS = 1
  40 R.!CS = 0
  R.!CS = 1
  32 R.!CS = 0
  2 R.!CS = 1
  48 R.!CS = 0
  R.!CS = 1
</pre>

<h3>Main Cycle for !CS</h3>
<pre>
  114 !CS = 0
  !CS = 1
  74 !CS = 0
  !CS = 1
  49 !CS = 0
  !CS = 1
</pre>

<h3>Main Cycle for SIO</h3>
This includes the effect of the SIO.!HOLD signal, since this EEPROM is held for those cycles.
<pre>
  7 SIO = 0
  2 SIO = 1
  22 SIO = 0
  SIO = 1
  24 SIO = 0
  2 SIO = 1
  14 SIO = 0
  SIO = 1
  7 SIO = 0
  SIO = 1
  14 SIO = 0
  2 SIO = 1
  SIO = 0
  SIO = 1
  6 SIO = 0
  2 SIO = 1
  13 SIO = 0
  SIO = 1
  2 SIO = 0
</pre>

<h3>Main Cycle for SIO.!HOLD</h3>
<pre>
  25 SIO.!HOLD = 1
  17 SIO.!HOLD = 0
  24 SIO.!HOLD = 1
  49 SIO.!HOLD = 0
  25 SIO.!HOLD = 1
  17 SIO.!HOLD = 0
  24 SIO.!HOLD = 1
  9 SIO.!HOLD = 0
  25 SIO.!HOLD = 1
  25 SIO.!HOLD = 0
</pre>

<h3>Cycle Placement</h3>
<p>Since the main processor cycle takes 240 clock cycles, a 1024-bit EEPROM
can contain 4 main cycles. Since the SIO cycle is held for 117 of these
cycles, it only takes 123 cycles, and the 1024-bit EEPROM could
hypothetically hold 8 of them. However, in both cases there would be a
remainder of bits left over, since neither number evenly divides into 1024.
We need the two types of EEPROM to stay in sync with one another as these
remainders are handled.

<p>The 123 SIO cycles will fit 4 times into 512 bits, which allows the SIO
EEPROM to service 8 main processor cycles with SIO bits. There are 512 -
4*123 = 20 bits left over on the SIO EEPROM and 1024 - 4*240 = 64 bits left
over on the main EEPROMS. We thus need to hold the SIO eeprom for 64-20 = 44
cycles to sync the two EEPROMS up once every 4 cycles. These hold bits can be
placed anywhere in the empty region following the main cycle at the very end
of the SIO.!HOLD EEPROM.