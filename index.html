<!doctype html>
<title>A Simple CPU</title>
<style>
    html {
        background-color: #002b36;
    }
    body {
        color: #839496;
	      font-family: Georgia, serif;
        line-height: 1.5;
        max-width: 60ch;
    }
    h1,h2,h3,h4,h5,h6 {
        color: #93a1a1;
	      font-family: sans-serif;
        line-height: normal;
    }
    p {
        text-align: justify;
    }
    .intro {
        break-inside: avoid;
    }
    code, pre {
      font-size: large;
    }
</style>

<div class="intro">
<h1>A Simple CPU</h1>
<h2>What Does it Take?</h2>
<p>If I wanted to make a CPU "from scratch," what would it take? What is the
simplest CPU that can be built? Inspired by <i>The Toaster Project</i>, I've
been exploring this question.
</div>

<p>Right off the bat, I realized that "simplest" is extremely subjective and
vague. Depending on how this word is interpreted, it could range anywhere
from manually wiring relays using copper wire to buying a CPU off the shelf.
For the game to be any fun, it'll need some rules.

<p>The rules can be whatever we like, but the goal of making a simplest CPU
will necessarily involve, at least in part, the most gratiutous allowable
abuse of the rules. Accordingly, the nature of the rules will control a great
deal of the project's nature. After carefully examining the consequences of
various rule sets, I've chosen the following:
<ul>
    <li>The CPU should be integrable in a "real system". Together they should
    be capable of doing usual computer things like I/O, addition,
    subtraction, etc.
    <li>Any parts of the CPU purchased from the store must not be specifically intended
    for inclusion in a CPU.
    <li>No FPGAs, CPLDs or the like in the CPU. Purchased parts must be
    limited in the sorts of functions they be made to directly compute.
    <li>The CPU should use as few components as possible.
    <li>The CPU should be responsible for the overall control of data
    processing in the system. While this rule is very vague, it's spirit
    rules out a class of cheats where a peripheral or the bus itself can be
    made so smart as to make the CPU too trivial.
    <li>The rest of the system will be played by a Raspberry PI's GPIO
    pins (3.3V).
</ul>
</div>

<div class="intro">
<h2>The Interface</h2>
<p>Before we delve into the design of such a CPU, what function must a CPU
actually perform in a system? The simpler the CPU's job can be made, the
simpler it's design can be. Well, in a modern computer architecture, a CPU
communicates with the rest of the computer via a bus. Over the bus, the CPU
requests information and delivers the results of computations to the
appropriate subsytems, as directed by the users program, stored in memory.
</div>

<p>The most important device sitting behind a bus is the main memory, so
let's start there. There are two operations the CPU could issue to the memory
via the bus: read and write. Both involve an address and one byte of data.
For a read, the CPU supplies the address to the bus, and the memory supplies
the data to the bus. For a write, the CPU supplies both the address and the
data to the bus.

<p>Some CPU designs have dedicated techniques for handling other non-memory
peripherals, but using memory-mapped I/O, essentially any hardware device can
be controlled with just the above two operations: read and write. Each device
connected to the CPU via the bus gets its own dedicated address range, and
exposes its functionality to the CPU in terms of reads from and writes to
those locations. The main memory chip only responds to address regions that
correspond to RAM; these and the memory regions for each device on the bus
are mutually exclusive.

<p>I like 8-bit systems with 16-bit addresses, so let's start there. This
gives us 64KB of addressable space over the bus, with 256 values per word.
Now, physically, how might the CPU request and deliver words with the rest of
the system? A simple bus design is the Serial Peripheral Interface (SPI). SPI
communicates data between a master (the CPU) and various chips using a clock
line (SCLK), a master serial output (MOSI), a master serial input (MISO), and
a chip select line (CS). The basic idea is that CS selects a chip, and the
CPU can send bits of data to it using MOSI, while the chip can send bits
of data to the CPU using MISO. The timing of the data is controlled by
SCLK. Once the operation is finished, CS deselects the chip.

<p>SPI can be used in a number of configurations. For reasons I'll get into
later, let's say the leading edge of the clock is the rising edge (CPOL=0).
Inputs are captured on the leading edge of the clock, while outputs are
changed on the trailing edge of the clock (CPHA=0). Furthermore, we'll only
use SPI in half-duplex mode, meaning only one of MOSI and MISO can be driven
at a time. They can thus share a wire; we are using SPI in "three-wire mode."
We can thus combine the MOSI/MISO lines into one; call it SIO.

<p>There are two operations the CPU can do on the bus: read and write. Since
there are just two operations, the CPU only needs to send one bit to the bus
to indicate which operation is being performed. It would seem to be simplest
to just begin each operation by sending this bit over SIO, but it's actually
a bit simpler to include an additional wire for this. The reasoning will
become clearer once the internals of the CPU are discussed, but the jist is
that all of the other bits that will be sent to the bus are copies of bits
originally received from the bus. This is not the case for the operation bit,
which is sourced from the CPU's internal control logic. These two functions
are necessarily performed by different chips, and so both would need to drive
the bus at different times if this bit were sent across the bus. By sending
the operation on an additional wire, this can be avoided.

<p>A conceptually simpler way to do the above is to have two CS lines instead
of one: a READ line and a WRITE line. We'll take each to be active high, and
each begins and ends the corresponding operation. Only one may be active at a
time.

<p>So, we can take our CPU to have 7 connected pins: VCC, GND, CLK, SIO,
SCLK, READ, and WRITE. SCLK is the SPI serial clock, while CLK is an internal
clock. Both are inputs to the processor, and SCLK must also be available to
the bus. SCLK must be exactly 1/8th the frquency of CLK and should be nearly
in phase. This allows CLK to drive an 8-bit shift register for each tick of
SCLK, which is important to the CPU's implementation.

<p>Now that we have a "physical layer," we need a protocol to send over it.
We begin an operation by asserting READ or WRITE and sending the the 16-bit
address. If the operation was a read, the CPU listens for the result (after a
bit; more on this below). If the operation was a write, the CPU sends the
bits to write. For as long as CS is selected, bus will continue to send or
receive additional data, which will be considered to apply to successively
increasing addresses with a 64KiB wraparound. The operation ends when the CS
line is deselected; this must occur on an 8-bit boundary, and at least 8 bits
of data must be read/written.

<p>Now for something very mysterious: on each READ cycle, after the CPU sends
the address, the bus cycle waits exactly 25 SCLK cycles before sending the
data. Why on earth would we do that? Well, the memory that we'll be using
inside the processor will need exactly 25 cycles to be prepared to store the
data from the bus at the appropriate internal location. This is almost
cheating, but not quite; the bus can be pretty darn custom to internal CPU
operations, but the CPU is still in charge; it can issue whatever reads and
writes it wants. Anything else can drive the bus for that matter, so long as
it can cope with this 25 cycle delay.

<p>The bus design is not very original; it's a fairly tweaked version of a
real Microchip SPI SRAM. Thus, there's good reason to think a practical bus
controller could implement it, and we needn't feel too bad coding up this
logic in Python in our Raspberry PI.

<div class="intro">
<h2>The Instruction Set</h2>
<p>Now that we have a mechanism for the processor to speak with the rest of
the system, what will it talk about? Traditionally, the processor reads an
instruction from the system, then does some arithmetic operation or other
internal processing. Some instructions may read values from the system, write
values to the system, or both.
<div class="intro">

<p>When designing the instruction set, how many instructions are necessary?
If the goal is to be as simple as possible, it turns out the answer is one.
There are a dazzing variety of "one instruction set computer" architectures,
where the computer has exactly one way of interacting with the rest of the
system, that it repeats indefinitely. Even so, given the magic of
Turing-completeness, the processor is able to simulate far more rich
instruction sets.

<p>Of all the Turing-complete instructions available, which should we select?
Our chosen bus suggests a natural answer. An OISC called "byte byte jump"
consists exclusively of the two basic operations: read and write. Couldn't be
simpler for our architecture.

<p>A byte byte jump instruction consists of the following 48-bits:
<ul>
    <li>A 16-bit source address
    <li>A 16-bit destination address
    <li>A 16-bit jump address
</ul>

<p>A CPU implementing byte byte jump would do the following repeatedly:
<ul>
    <li>Read the 48 bits at processors instruction pointer.
    <li>Read the 8 bits at the source address and then write them to the source address.
    <li>Change the processor's instruction pointer to the jump address.
</ul>

<p>That's it! A CPU capable of doing the above can compute any computable function.
</div>
</div>

<h3>The Synthesis of Addition</h3>
<p>To provide an intuition of how computation can be done with just a move
instruction, we will now synthesize an addition macro instruction from the
above. This section stands on its own; feel free to skip it if you believe that
the above instruction is both sufficient and practical.
</div>

<p>First, a few notational conventions. Let's refer to our base instruction as
follows:
<pre>
loc: MOV src dst [jmp] -- comment
</pre>

<p>The <code>jmp</code> argument is optional; if omitted, the address of the
next instruction. <code>loc</code> refers to the address of the instruction
itself. Comments begin with <code>--</code> and continue until the end of the
line. Temporary locations are indicated by <code>t[n]</code>, for some positive
integer <code>n</code> (optional). Locations and temporaries are considered
local to each macro instruction. We will avoid here specifying how the
instruction is laid out in RAM, but each part of an instruction at loc
can be referred to using loc.src, loc.dst, or loc.jmp.

<pre>
MOV_INDIR src lo dst [jmp]:
  -- *target = *(src &lt;&lt; 8 | *lo)
  MOV lo loc.src+1
  loc: MOV src dst jmp

MOV_INDIR16 hi lo dst [jmp]:
  -- *target = *(*hi &lt;&lt; 8 | *lo)
  MOV hi loc.src
  MOV lo loc.src+1
  loc: MOV 0xDEADBEEF dst jmp
</pre>

<p>Given indirect accesses, we can now construct and use tables. The contents
of various tables can be presented to the CPU by attaching ROM chips to the
system bus, or by loading them into RAM during a bootstrapping procedure.
Regardless, we can feel free to presume that whatever data we want can be
preloaded into RAM at whatever addresses we wish.

<p>Imagine we have a giant table that takes up the entire 64KB address space.
Such a table could be indexed by a pair of 8 bit values; one forming the high
byte of the value, and the other forming the low byte. In such a table, we
could just store the sum of the two indices; an indexed lookup into this
table would allow adding any two 8-bit values.

<p>Unfortunately, this wouldn't leave room in the address space for anything
else. But, we can instead consider a 4-bit sum table. The complete table of
4-bit vs 4-bit sums occupies only 256 addresses, and can be indexed using a
single byte. All such tables would need to be aligned to 256-bytes. Let's call
this table <code>sum4[256]</code>:

<pre>
ADD4 a dst [jmp]:
  -- *dst = (*a &gt;&gt; 4) + (*a &amp; 0x0F)
  MOV_INDIR sum4 a jmp
</pre>

<p>However, to use this, we need to be able to manipulate the high and low
4-bit portions of bytes. Let's build a handful of 4-bit manpulation
operators. Afterward, we'll see how they can be used to transform a 4-bit
table-based addition into a full 8-bit addition.

<p>First, let's build 4-bit left and right shift operators, using
<code>ls4[256]</code> and <code>rs4[256]</code> tables, respectively:

<pre>
LS4 src dst [jmp]:
  -- *dst = *src &lt;&lt; 4
  MOV_INDIR ls4 src jmp

RS4 src dst [jmp]:
  -- *dst = *src &gt;&gt; 4 &amp; 0x0F
  MOV_INDIR rs4 src jmp
</pre>

<p>Now, to use ADD4 to add the 4 low bits of one byte to the 4 low bits of
another, we need some way to merge together the low 4 bits of two bytes into
one. This would seem require a pair of 4-bit table lookups: merge4[16][16], but
our indirection trick only operates at a byte-level granularity.

<p>Say the first set of 4 bits was fixed, and we only needed to vary over the
second. We'd have 16 merge4 tables: merge4_0[256] to merge4_15[256]. Each of
them would store a value with 4 high bits of 0..15, and the low 4 bits of the
index. Now say we store these 16 tables consecutively from 0 to 15, and align
the whole 4096 bytes on a 4096-byte boundary. Now the 4 high bits of every
address in any of the tables are the same, and the low 4 bits of the high byte
selects the table. Thus, to find the right table location, we only need to
overwrite the 4 high bits of the first index with the 4 high bits of the table.
This we can do with yet another table, merge4[256].

<p>Putting it all together, we get the following:

<pre>
MERGE4 hi lo dst [jmp]:
  -- *dst = (*hi &amp; 0x0F) &lt;&lt; 4 | (*lo &amp; 0x0F)
  MOV_INDIR merge4 hi t
  MOV_INDIR16 t lo dst jmp
</pre>

<p>Now we can add the 4 low bits or the 4 high bits of two bytes:

<pre>
ADD4_LO a b dst [jmp]:
  -- *dst = (*a &amp; 0x0F) + (*b &amp; 0x0F)
  MERGE4 a b t
  ADD4 t dst jmp

ADD4_HI a b dst [jmp]:
  -- *dst = (*a &amp; 0xF0) &gt;&gt; 4 + (*b &amp; 0xF0) &gt;&gt; 4
  RS4 a t
  RS4 b t1
  ADD4_LO t t1 dst jmp
</pre>

<p>Finally, we can combine the two, producing the full 8-bit ADD:

<pre>
ADD a b dst [jmp]
  -- *dst = *a + *b
  ADD4_LO a b t -- low 4 bits = low addition
  RS4 t t1 -- low 4 bits = carry of the low addition
  ADD4_HI a b t2 -- low 4 bits = high addition without carry
  ADD4_LO t1 t2 t3 -- low 4 bits = high addition with carry
  MERGE4 t3 t dst jmp
</pre>

<div class="intro">
<h2>Implementation</h2>
<p>Here we take <code>&X</code> to be the address of the location
<code>X</code> in R. The instructions are laid out in RAM in the order jmp,
src, dst. * by itself indicates a repeat of the previous state.

<pre>
IP = 0
SRC = 2
DST = 4
VAL = 6

SIOOp(RAddr, Op, Body):
  -- Begins a SIO operation at the address
  -- given by an address in R, executes the given body,
  -- then ends any outstanding operations.

  -- Select R and send it read code (00000011).
  6 R.CS = 0; R = 0; R.CTRL = 1
  2 R = 1

  -- Write the address to R; begin op on SIO.
  16 R = RAddr

  -- R sends the address to SIO.
  16 Op = 1

  Body()

  -- End the operation for both R and SIO
  R.CS = 1; READ = 0; WRITE = 0

WriteRFromSIO(RAddr,Size):
  -- End outstanding operation on R.
  R.CS = 1

  -- Begin new operation on R and send it write code (00000010).
  6 R.CS = 0; R = 0
  R = 1
  R = 0

  -- Send the write address to R.
  16 R = RAddr

  -- The bus writes to R.
  -- Bus contention will occur here, but if our
  -- CPU burns up, few tears will be shed.
  Size R.CTRL = 0

Loop:
  SIOOp(IP, 0, { WriteRFromSIO(IP, 48) })
  SIOOp(SRC, 0, { WriteRFromSIO(VAL, 8) })
  SIOOp(DST, 1, { 8 * })
</pre>

There are only 2 control signals that need to be driven: SIO and CS. We can
do so with 2 EEPROMs, each clocked with the inverse of SCLK. Both EEPROMs
need at least 278 bits of storage. The EEPROM driving SIO will need to be
periodically tri-stated so the bus can drive SIO. This can be done by driving
its HOLD input with another EEPROM, for 3 in total. These 3 EEPROMs plus the
memory allow us to build the while CPU with just 4 chips.

For the EEPROM we may be able to use:
https://www.mouser.com/ProductDetail/Microchip-Technology/25LC010A-I-P?qs=sGAEpiMZZMsBc9mHkjPmUACkC2Ne363fBzHrY%252B73jQQ%3D
This holds 1KiBit and follows the SPI protocol.